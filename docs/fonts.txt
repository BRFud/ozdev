Font Editing and Manipulation Utilities and Font Files


1. Loading fonts into Wizard

Fonts are normally stored on the PC in binary files with .wzf extension,
in the format described in Section 1.2.1.A of liboz.txt.  (Note that all
word-length data is stored in Wizard format, i.e., least significant byte
first.)

You can load fonts into the C-based file system by using ToMemo to
transfer them to the Wizard with special owner ID 999, and then either
running frommemo on the Wizard, or running some program, like the Fonts
browser or Wizbook, which has frommemo functionality built-in.  More
precisely, to transmit fonts font1.wzf and font2.wzf to the Wizard, do:
        tomemo -e fonts 999 fn font1.wzf font2.wzf
Here, the -e tells tomemo to remove the extension (.wzf) from the font
filenames before they are loaded into the Wizard.  The "fn" indicates
the name of the directory to store the fonts in on the Wizard, which
should be "fn".  And the 999 is the owner ID of font files.

You can also use the handy font2wzd converter if you have just one font
to convert.  If you have font.pdb (Palm font), font.data (Mac font),
font.txt (text font for txt2wzf) or font.wzf (a .wzf font already produced
by some utility), then you can do:
        font2wzd font
to produce font.wzd which you can upload.  This checks in order whether
you have a .pdb, a .data, a .txt or a .wzf file, and runs tomemo.


2. Viewing fonts on Wizard

Use the FONTS.WZD program in the FONTS directory to view fonts on the
Wizard and to load fonts into either slot 0 or slot 1.  The fonts can
also be used in MemoEdit (see EDIT\EDIT.WZD) so you can play around with
how they look.


3. Font encodings

All fonts are supposed to include the standard ASCII characters 32-126.
Unsupported characters should be replaced by an asterisk.  Moreover, all
fonts generated by the font utilities included with this SDK will include
some support for the extended characters used by MemoEdit.  These characters
are:
        127: acute-e
        1: acute-o
        2: acute-u
        3: acute-a
        4: grave-e
        5: grave-o
        6: grave-u
        7: grave-a
        8: degree
        9: bullet
        10: tilde-N
        11: mu
        12: euro
        13: newline character
        14: circumflex-e
        15: circumflex-o
        16: circumflex-u
        17: circumflex-a
        18: circumflex-E
        19: circumflex-O
        20: umlaut-e
        21: umlaut-o
        22: umlaut-u
        23: umlaut-a
        24: umlaut-E
        25: umlaut-O
        26: umlaut-U
        27: umlaut-A
        28: German ss
        29: cedille-c
        30: superscript-2
        31: tilde-n
When a character is not available in a font, it is replaced by the font
utilities by a similar available character.  Thus, an accented character
will be replaced by an unaccented character when available.

Thus, the encoding of characters 1-127 is fixed, though some
substitutions are possible.  Some fonts have a strict ASCII character
set. The fonts are supposed to be indicated by filenames than end in an
"A" marker, e.g., "Alpha_BK_A".  These always substitute an ASCII
character for characters 1-12, 13-31 and 127.  Character 13 is always
supposed to be a newline-like character, though.  This is a special
favor to MemoEdit. In fact, a lot of the font stuff shows special favor
to MemoEdit.  The favoritism is due to the fact that the font stuff was
initially implemented by the author of MemoEdit!

Character 0 is unsupported at the moment.  Characters 128-255 can come
in several encodings, though not all fonts support them.

Fonts that do support characters 128-255 are supposed to have at the end of
their filename the capital letter M or E.  If the character is "M", then
these characters are given in standard Macintosh encoding.  If the character
is "E", then these characters are given in the Windows Latin 1 encoding,
which happens to be more or less the encoding used by the built-in Wizard
FONT_PC_* fonts and by Palm Pilot fonts.

The DOS encoding for characters 128-255, supported only in the 4x6 and 8x8
fotns, is indicated by _X at the end of the filename.

If a font only supports characters up to 127, then the high bit in the
character is ignored by ozputs() and related functions


4. Converting fonts to .wzf format

The utilities for converting fonts to .wzf format are still a little
hackish.  There are basically two utilities, source for which are in the
FONTS directory.

Make sure you obey all applicable software license, patent, copyright
and other laws in your location when converting third-party fonts.

4.1. GETMACFONT, GETPRCFONT and FONT2WIZ

Conveniently, except for encoding, both Palm and Macintosh bitmap fonts
are stored in basically the same NFNT format.  Palm fonts typically come
in a Palm Database format, indicated by the extension .PDB.  The FONT2WIZ
program can convert a .PDB file directly into a .WZF file in an automated
fashion.  This will be explained below.

A Mac font requires a touch more work.  You need to transfer the Macintosh
font to your PC in MacBinary (or MacBinary II) format.  In fact, you can
transfer any file (subject to copyright and other law) that includes a
bitmap font resource in MacBinary format in this way.  Once you have a
MacBinary format file named, say, font.bin on your PC, you need to extract
all font resources from it.  To do this, use:
        getmacfont font.bin
The getmacfont creates files, with names ending in ".data", containing each
of the bitmapped fonts in font.bin (theoretically, there could be more than
one).  (In fact, getmacfont is a general-purpose resource extractor.
You can, say, extract ABCD resources by doing: getmacfont data.bin ABCD.)
Older Macintosh fonts may be stored in FONT, not NFNT resources.  Font2Wiz
seems to work fine with those, too.  If you find that getmacfont font.bin
has no effect, try to extract the FONT resources:
        getmacfont font.bin FONT

If instead of a MacBinary file you have a pure resource fork file, make sure
that the input filename ends in .rsrc, and all will be well.

Once you have the .DATA files, you can feed them into FONT2WIZ.

To use FONT2WIZ, make sure you have a font.pdb or font.data file (the former
being a standard Palm data file and the latter being a font resource file
generated, e.g., by getmacfont).  Then, do:
        font2wiz font [options]
for a Palm .pdb font or:
        font2wiz font r m [options]
for a Macintosh .data font resource.  Make sure you omit the extension
on the font.  You will get font.wzf coming out (or perhaps a slightly
renamed version, with the renaming indicating encoding options or removing
spaces in the filename)

There are a number of options available.  Each option must be given at
the end of the palm2wiz command-line with spaces in between them.  Here
are the options:

        r -- Input file is a (usually Macintosh) resource with .data
             filename, not a Palm database, as is default.  You can use
             the r option to read in a Palm resource as well, if you
             have the font in raw resource binary format.

        m -- This tells palm2wiz that the input font has Macintosh
             encoding.

        a -- This produces a plain ASCII encoding (see the information
             encodings above), and a font ending in "A".

        e -- This grabs all of the characters 32-255, instead of the default
             32-126, from the input font.  It produces a font ending in "E"
             to indicate the availability of extended characters, unless the
             "m" option was given to indicate a Mac font, in which case we
             get a "M" font, encoded in Macintosh format.

        E -- This grabs all of the characters 32-255, but transposes them
             from Macintosh format to an approximation of Windows Latin 1.
             It generates an "E"-marked font filename.  You do not need
             to specify "m" if you specify "E"--the "m" is automatically
             implied.

        M -- If the default encoding system is used that only includes
             characters 32-126, the special MemoEdit characters in
             1-31 and 127 are included only when they do not increase the
             height of the font--FONT2WIZ tries to minimize font height--
             and replaced by plain ASCII otherwise.  (If the "a" option
             is included, then it always replaced by plain ASCII characters.)
             The M option overrides this and tries to include as many
             MemoEdit special characters as possible.

        q# -- This squishes down a font by the specified number of pixels.
             Use this to reduce the height of a bitmap font where all the
             characters are just a bit shorter than a handful of unimportant
             characters, and you want everything at the shorter length.
             For instance, some fonts will have the ` and ^ characters be
             taller than other characters.  If you specify the q1 option,
             these characters will be shifted down by one pixel and the
             other characters will lose some blank space on top.  This is
             important for devices like the Wizard where space is at a
             premium.

        R#
        L# -- Adjust left/right kerning.  For instance, some fonts may look
             spaced too widely.  For them, you can put L-1 or R-1 to
             decrease the spacing on the left or right.  Others may look
             too closely spaced.  For them, you can put L1 or R1.

        n -- Disable kerning information processing.  Some fonts, for reasons
             I have not been able to discern, screw up their widths when
             one takes into account the kerning information.  Either they
             will be too widely spaced or irregularly spaced.  Including the
             "n" option will help.

        d -- Show the characters as they are being read in from the font
             file.

If instead of a Palm .PDB database you have a Palm .PRC resource file, you can
extract all the fonts with getprcfont.  The usage is just as for getmacfont
(and it, too, can extract other resources than the FONT resource), and
it produces .data files that can be read into font2wiz if you give it the "r"
option.  (But don't give it the "m" option then!)

4.2. DFONT

This is definitely a hackish routine.  It takes as input a graphic image
of a font in a monochrome .bmp file and produces a .wzf font file.  The
.bmp file must be a bitmapped image in an appropriate format.  The format
is:
        _ xygTW|{[&^_@#`~ sample

        _ _ _!_ _"_ _#_ _$_ _%_ _&_ _'_ _(_ _)_ _*_ _+_ _,_
        _-_ _._ _/_ _0_ _1_ _2_ _3_ _4_ _5_ _6_ _7_ _8_ _9_
        _:_ _;_ _<_ _=_ _>_ _?_ _@_ _A_ _B_ _C_ _D_ _E_ _F_
        _G_ _H_ _I_ _J_ _K_ _L_ _M_ _N_ _O_ _P_ _Q_ _R_ _S_
        _T_ _U_ _V_ _W_ _X_ _Y_ _Z_ _[_ _\_ _]_ _^_ ___ _`_
        _a_ _b_ _c_ _d_ _e_ _f_ _g_ _h_ _i_ _j_ _k_ _l_ _m_
        _n_ _o_ _p_ _q_ _r_ _s_ _t_ _u_ _v_ _w_ _x_ _y_ _z_
        _{_ _|_ _}_ _~_

(This text is found in FONTS/SAMPLE.TXT)

The important thing is that the first line must start with an underline
character, must include the highest ascending and lowest descending characters
and must be solid in between in the sense that one cannot draw a blank
horizontal line anywhere through it.  For all fonts I've looked at, this
example works.  Then must follow a blank line.  After that, follow the
character records for ASCII characters from 32 to 126.  Each character
is listed between two underline characters, followed by a space.
Line breaking can happen anywhere between records, but not within a record.
(Thus, you can break the line after "_3_".)  The dfont program will then
take the .bmp file and try to grab the font from it.  This assumes several
things.  First of all, the left hand margin of every line must be even.
Secondly, the font must actually have an _ character.  Thirdly, the font
cannot kern left (kern in a way that overlaps the _ character).  There
are also a few other more technical assumptions.  Assuming all is well,
you can run:
        dfont fontname
to transform fontname.bmp to fontname.wzf.

Finally, it is assumed that the font's _ character generates a solid
underline if several of them are put together.  If two underline characters
generate an underline with a small break in them, you will need to specify
at the end of the dfont command-line a left-width adjust parameter equal to
the length of this break.  Normally in such a case the following works:
        dfont fontname l1
But if the break is more than one pixel in size, you will need to increase
the "1".  (Technically, the "l#" tries to trim each character on the left
by the specified number of pixels.)

Using dfont can be a tricky process, especially if the font's _ character
doesn't general a solid underline when combined with another one, or if
funny kerning kicks in.  Because of this, you may need to preview how the
font is scanning.  To do this, include a "d" at the end of the command-line,
e.g.:
        dfont fontname l1 d
You may also need to adjust manually the widths of some characters if dfont
is failing to recognize the characters.  The widths should include at least
one blank pixel to the right of the character.  To adjust the width for, say,
the character ^ to 4, do:
        dfont fontname m^4
You can include as many mc# commands, where c is a character and # a number
as you need.


5. Editing fonts with a text editor

You can edit fonts with any text editor, though you will do better if your
text editor itself uses a fixed-width font like Courier.  To do this, just
create a file that starts with the following lines in exactly this order:

0 (first)
127 (last)
10 (bitmap_height)
10 (line_height)

You will need to modify the last, bitmap_height and line_height values to
match your font.  The "first" value must be zero.  The "last" value indicates
the last character present in your font, which must be 127 or 255.  The
"bitmap_height" value is the height of each font entry.  The "line_height"
value is at least as big as bitmap_height and is the recommended line spacing,
though this is currently not supported by Wizard software.

After this follows a list of character records.  These do not have to be
in sequence.  Each record starts with a line having two numbers.  The first
number is the character number.  The second number is a redirect number,
which means that to display this character the Wizard will be redirected to
the other character.  If you don't want to redirect, both values are the same.
If you omit the second value, it is assumed to be the same as the first.
Instead of a number in these lines, you can also specify 'c where c is a
character (other than a space) or even just c (unless the character is a
' or a digit). After this, follows a bitmap of the character, unless the
character is redirected.  The bitmap is a set of lines, bitmap_height in
number, each of the same length, with a period indicating a white pixel
and any other character (including a space) indicating a black pixel.
Thus, the beginning of one of the Smithz fonts looks as follows:
0 (first)
127 (last)
10 (bitmap_height)
12 (line_height)
0 101 (redirected)
1 1
..XX..
.XX...
......
.XXX..
XX.XX.
XX.XX.
XX.XX.
.XXX..
......
......
2 2
..XX..
.XX...
......
XX.XX.
XX.XX.
XX.XX.
XX.XX.
.XXXX.
......
......


Here, the "0 101" record indicates that character number 0 is to be
redirected to character number 101 ('e').  Then you get the bitmaps
for characters 1 and 2.  You could also have said for clarity:
        0 'e
instead of
        0 101

Please do not have circular redirections.  I have no idea what will
happen--your Wizard or PC may crash if it runs into them.

Note: You can omit the data in ()'s in the example file--the ()'s in the
header lines as well as the "(redirected)" are just comment lines ignored
by the system.  Do not add such comments in the bitmap lines or in the
lines indicating the start of a character where there is no redirection and
where you give only one number--doing the latter will redirect to a '('
character!


Once you create a font.txt text file with the font in the above format
(all lines aligned at the left hand margin, no blank lines), you can
create a font.wzf font file by running:
        txt2wzf font


You can edit an existing font by converting it to a text file by running:
        wzf2txt font
given font.wzf.


6. Importing fonts into programs with WZF2PROG.

The WZF2PROG utility takes a .wzf font and generates C or Z80 assembly
file that can be included in your program.  Given fontname.wzf, do:
WZF2PROG fontname to generate fontname.c and WZF2PROG -a font to
generate fontname.as.

The following are instructions for the C version.  The assembly version
is similar, though it doesn't include the auto-load stuff.

You can put at the top of your program:
#include "fontname.c"

Then, to print using the given font, all you need to do is:
        ozsetfontpointer(fontname_data);
Note that fontname.c also defines the handy macro fontname_length which
indicates the length of the font.  (Note that "fontname" needs to be
replaced throughout by the actual name of the font, say:
ozsetfontpointer(Alpha_BK_A_data).  If the fontname starts with a number,
add an underline at the beginning.)

You should have a look at fontname.c, because you may need to edit it
slightly for your own uses.  One handy little thing that fontname.c
provides is a program that loads the font into a slot without the need
for a font manager.  To enable this, #define LOAD_FONT, or just compile:
        zcc -z -DLOAD_FONT fontname.c
Then, the fontname.wzd program lets you load the font into a slot.


8. Sample fonts.

The SDK includes several sets of free fonts as an example. These are
included in FONTS\SAMPLES.  The SAMPLES directory is divided into several
subdirectories including: COOLFNTS, ALPHAFONTS and SMITHZ.  In each of
these directories, you will find a .ZIP archive containing the original
font files for the font sets and a README.TXT specifying the special
legal rules governing use of the font.  Basically, COOLFNTS and SMITHZ
are free for all use on Sharp 7xx organizers, if the fonts are not
renamed and proper credit is given.  ALPHAFONTS is free for
noncommercial nonshareware use.  Shareware use requires a donation to a
charity.

SMITHZ is a Macintosh font, while COOLFNTS and ALPHAFONTS are Palm fonts.

The .wzf files included are for the default 1-127 encoding.  You can
always generate files encoded in other ways if you like.  You will also
find some .wzd files.  These contain subsets of the fonts which you can
load into your Wizard.  The .wzd files are in FromMemo v.2 format.  After
loading them, you need to run Fonts or FromMemo v.2 on your Wizard to
put them into the file systems.

In the CYRILLIC directory, you'll find a sample cyrillic font.  The keyboard
mapping is explained in keyboard.txt.

Finally, the FONTS\SAMPLES directory contains 8x8_X.wzf and 4x6_X.wzf.
Many people asked how to use these two fixed-width fonts.  The 8x8 font
is a standard CGA font, and will be familiar to people from Othello and
AR-Chess.  The 4x6 font is used by Wizterm and ViewWeek.  The answer to
the question of how to use these fonts is easy now.  For instance, to
use the 8x8 font to put out a "Hello, world" message, copy the 8x8_X.wzf
font to your program directory.  Then, run:

        wzf2prog 8x8_X

Then, create hello.c:

#include <oz.h>
#include "8x8_X.c"

main()
{
   ozsetfontpointer(_8x8_X_data);
   ozcls();
   ozputs(0,0,"Hello, world");
   ozgetch();
}


Next, compile it:

        zcc -z hello.c


9. Right-to-left support

It is customary to rename right-to-left fonts to have a .wrf
extension instead of .wzf.  There is no direct right-to-left support on
the Wizard--you need to reverse the order of the characters yourself
before calling ozputs() with a right-to-left font.  Thus, you print
"shalom" with

        ozputs(0,0,"Mwls");

rather than with

        ozputs(0,0,"slwM");

(Using the sample Hebrew.WRF font's mapping.)  However, the .wrf extension
can be used as a hint to PC-based programs that interface with a Wizard
program.  For instance, the WizBookConverter will automatically set a
right-to-left flag in any ebook using a .wrf font.
