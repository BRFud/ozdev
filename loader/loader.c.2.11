#include <oz.h>
#include <string.h>
#include <ctype.h>

#define HIBYTE(x)  ( ( (byte *)&(x) )[1] )
#define LOBYTE(x)  ( * ( (byte *)&(x) ) )
#define HIBYTE_CONST(x) ( (byte)((x)>>8) )
#define LOBYTE_CONST(x) ( (byte)(x) )

static char category;
static byte modelM;
unsigned wrapup_address;
unsigned mygetch(void);
int findownedbasicfile(char *owner);
byte ozflashread(unsigned page,unsigned offset);
/* void ozflashwrite(unsigned page,unsigned offset,byte data); */
extern byte buffer[];
typedef char fname[MAX_FILENAMELEN+1];
static fname files[9];
static char loading_msg[]="Loading";
static char saving_msg[]="Saving";
#define filename (files[0])
#define name (files[1])
/* static char name[19+1]; /* 19<MAX_FILENAMELEN-2 */

byte ozputs0(char y,char *s)
{
	return ozputs(0,(int)y,s);
}

char cannotopen[]="Cannot open!";
char errorwriting[]="Error writing!";
char spaces[]="                  ";

static byte wrapup[18]=
{0x00,0x1E,0x09,0xFE,0x31,0x26,0x48,0x46,0x46,0x30,
	0x32,0x0D,0x00,0x28,0x03,0xFE,0x10,0x0D};

#define WRAPUP_PART2_ADDRESS 7

#define WRAPUP_CODE_END (0x7FDE+18)
extern byte Part2_routine[], end_Part2_routine[], Part2_central[],
	Part2_indir[];
extern unsigned Part2_central_addr,Part2_indir_addr;

unsigned storagepages[4]={ 0x404,0x405,0x408,0x409 };

unsigned codelength;

#ifndef CBASED

void copypage(unsigned dest,unsigned src);

#else

void copypage(unsigned dest,unsigned src)
{
	static unsigned d,s,i;
	d=dest;
	s=src;
	for(i=0;i<8192;i++)
	  ozmemwrite(d,i,ozflashread(s,i));
}

#endif

#define tohex(s,x) (s)[0]=nibble((x)>>12); \
				   (s)[1]=nibble((x)>>8); \
				   (s)[2]=nibble((x)>>4); \
				   (s)[3]=nibble(x)

char nibble(byte x)
{
	x&=0xF;
	if(x<10) return x+'0'; else return x+('A'-10);
}

unsigned ozgetch0(void)
{
	static unsigned k;
	k=ozgetch();
	switch(k)
	{
		case KEY_LOWER_ESC:
		case KEY_UPPER_ESC:
		case KEY_MYPROGRAMS:
			exit(0);
	}
	return k;
}


byte ozgets(byte _x,byte y,char *_s,byte length)
{
	static byte x;
	static byte stringpos;
	static unsigned k;
	register char *s=_s;
	x=_x;
	stringpos=0;
	while(KEY_LOWER_ENTER!=(k=mygetch()) && k!=KEY_UPPER_ENTER
	  && k!='\r' && k!='\n')
	{
		switch(k)
		{
/*
			case KEY_MAIN:
			case KEY_TELEPHONE:
			case KEY_SCHEDULE:
*/
			case KEY_MYPROGRAMS:
/*			  case KEY_MEMO:
				ozexitto(k);
*/
				 exit(0);
			case 27:
			case KEY_UPPER_ESC:
				 return 0;
			case 8: /* backspace */
				 if(stringpos)
				 {
					s--;
					stringpos--;
					x-=ozputs0(-1,s);
					ozputs(x,y,spaces);
				 }
			case '\\':
				 *s=0;
				 break;
			default:
				 if(k>=32 && k<127)
				 {
                   if(stringpos>=length) break;
				   x=ozputch(x,y,k);
				   *s++=k;
				   stringpos++;
				 }
				 *s=0;
		}
	}
	return *_s;
}

int clearslot(void)
{
	static byte slot,slot0,i;
	static int j;
	static int otherslot;
	for(slot0=0,slot=0x60;slot0<10;slot0+=2,slot+=8)
	{
		if('O'!=ozflashread(slot,0)
		&& 'O'!=ozflashread(slot+4,0))
		{
			ozflasherase(slot);
			return slot0;
		}
	}
	for(slot0=0,slot=0x60;slot0<10;slot0++,slot+=4)
		if('O'!=ozflashread(slot,0)) break;
	if(slot0==10) return -1;
	if(slot0 & 1) otherslot=slot-4;
	  else otherslot=slot+4;
	if(0xFF==ozflashread(slot,0)) return slot0;
	for(i=0;i<4;i++)
		copypage(storagepages[i],otherslot+i);
	ozflasherase(slot);
	for(i=0;i<4;i++)
	{
	  for(j=0;j<8192;j+=256)
	  {
		ozflashread256(storagepages[i],j);
		ozflashwrite256(otherslot+i,j);
	  }
	}
	return slot0;
}

void getname(byte slot)
{
	register char *s=name;
	static byte page;
	static unsigned offset;
	page=slot*4+0x60;
	offset=1+ozflashread(page,0xA);
	while(*s++=ozflashread(page,offset++));
	return;
}

int getslot(void)
{
	static byte slots[10];
	static byte i;
	static unsigned c;
	static byte numslots;
	static byte x,x1;
	static byte y;
	numslots=0;
	for(i=0;i<10;i++)
		if('O'==ozflashread(0x60+4*i,0))
			slots[numslots++]=i;
	ozcls();
	ozputs0(60,"Select slot:");
	x=y=0;
	for(i=0;i<numslots;i++)
	{
		if(i==5)
		{
			y=0;
			x=120;
		}
		x1=ozputch(x,y,i==9 ? '0' : i+'1');
		x1=ozputs(x1,y,". ");
		getname(slots[i]);
		ozputs(x1,y,name);
		y+=10;
	}
	ozputch(48/* from sizer */,60,c=ozgetch0());
	if(c=='0')
	{
		if(numslots!=10)
		  return -1;
		else return slots[9];
	}
	else
	{
		if(c<'1' || c>'9' || c>='1'+numslots) return -1;
		return slots[c-'1'];
	}
}

void filetoslot(byte _slot)
{
	static byte page,slot;
	static unsigned offset;
	static byte x;
	x=ozputs0(70,loading_msg);
	ozputs(33,70,spaces);  /* the 33 was generated by SIZER */
	slot=_slot*4+0x60;
	for(page=slot;page<slot+4;page++)
	{
		x=ozputch(x,70,'.');
		for(offset=0;offset<8192;offset+=256)
		{
			if(read1(&buffer,256)<=0) return;
			if(!offset && page==slot) buffer[0xE]=_slot+1;
			ozflashwrite256(page,offset);
		}
	}
}

void filetomem(void)
{
	static byte page;
	static unsigned offset;
	static unsigned start_offset;
	static unsigned name_offset;
	static byte x;
	register char *p;
	x=ozputs0(70,loading_msg);
	read1(&buffer,0xA);
	read1(&name_offset,2);
	read1(&start_offset,2);
	read1(&buffer,name_offset-0xC-1);
	p=name;
	do
		read1(p,1);
	while(*p++);
	read1(&buffer,start_offset-name_offset-(p-name));
	read1(&codelength,2);
	if(codelength>wrapup_address)
	{
		ozputs0(70,"Out of memory!");
		ozgetch();
		exit(0);
	}
	for(page=0;page<4;page++)
	{
		x=ozputch(x,70,'.');
		for(offset=0;offset<8192;offset+=256)
		{
			if(read1(&buffer,256)<=0) return;
			ozmemwrite256(storagepages[page],offset);
		}
	}
}

void slottofile(byte _slot)
{
	static byte page;
	static unsigned offset;
	static unsigned size;
	static unsigned wrote;
	static byte x;
	static byte slot;
	slot=_slot*4+0x60;
	offset=1+ozflashread(slot,0xC);
	size=offset+2+ozflashread(slot,offset)+(ozflashread(slot,offset+1)<<8);
	x=29;
	wrote=0;
	for(page=slot;page<slot+4;page++)
	{
		x=ozputch(x,70,'.');
		for(offset=0;offset<8192;offset+=256)
		{
			ozflashread256(page,offset);
			if(size-wrote<=256)
			{
				if(write1(buffer,size-wrote)<size-wrote)
				{
					ozputs0(70,errorwriting);
					ozgetch();
				}
				return;
			}
			if(write1(buffer,256)<256)
			{
				ozputs0(70,errorwriting);
				ozgetch();
				return;
			}
			wrote+=256;
		}
	}
}

char *getnextfilename(byte mode)
{
	register char *f;
	static byte m;
	m=mode;
	while(1)
	{
		f=ozgetnextfilename(m);
		m&=~FIND_RESET;
		if(f==NULL || !category
		||
		(category=='-' && (f[1]!='/' || f[0]<'a' || f[0]>'z'))
		||
		(f[0]==category && f[1]=='/') ) return f;
	}
}


char *selectname(void)
{
	static byte refresh;
	static byte pos;
	static byte x;
	static unsigned i;
	static unsigned k;
	static unsigned curpos;
	register char *f;
TOP:
	curpos=0;
	f=getnextfilename(FIND_OWNED | FIND_RESET);
	if(f==NULL)
	{
		if(category)
		{
			category=0;
			goto TOP;
		}
		ozcls();
		ozputs0(0,"No Loader files!");
		ozgetch();
		return NULL;
	}
	do
	{
		ozcls();
		for(pos=i=0;i<9;i++,pos+=8)
		{
			if(i && NULL==(f=getnextfilename(FIND_OWNED))) break;
			strcpy(files[i],f);
			ozputch(0,pos,i+'1');
			ozputch(5,pos,'.');
			if(f[1]=='/' && f[0]>='a' && f[0]<='z')
			{
				ozputs(9,pos,f+2);
				if(!category)
				{
                    ozputch(148,pos,'[');
                    x=ozputch(151,pos,f[0]);
					ozputch(x,pos,']');
				}
			}
			else ozputs(9,pos,f);
		}
		curpos+=9;
		if(NULL!=f) f=getnextfilename(FIND_OWNED);
		ozputs0(72,"1-9:select, a-z/sp/-:category, \x0A/\x0B:navigate, ESC:cancel");
		if(NULL!=f) ozputch(232,72-8,11);
		if(curpos>9) ozputch(232,0,10);
		if(category)
		{
			ozputs(190,10,"category");
			ozputch(190+41,10,category);
		}
		refresh=0;
		do
		{
		  k=ozgetch0();
		  switch(k)
		  {
			case KEY_PAGEUP:
			case KEY_UP:
				if(curpos>=18)
				  {
					curpos-=18;
					f=getnextfilename(FIND_OWNED | FIND_RESET);
					for(i=0;i<curpos;i++)
					  getnextfilename(FIND_OWNED);
					refresh=1;
				  }
				 break;
			case ' ':
				category=0;
				goto TOP;
			case '-':
				category='-';
				goto TOP;
			case KEY_PAGEDOWN:
			case KEY_DOWN:
				if(f!=NULL) refresh=1;
				break;
			default:
				if(k>='a' && k<='z')
				{
				  category=k;
				  goto TOP;
				}
				if(k>='1' && k<'1'+i) refresh=1;
		  }
		} while(!refresh);
	} while(k<'1' || k>='1'+i);
	return files[k-'1'];
}

void confirm_no_basic(byte slot)
{
	static unsigned offset;
	static char idname[12];
	static unsigned page;
	static byte i;
	page=4*slot+0x60;
	offset=1+ozflashread(page,0x8);
	for(i=0;i<12;i++)
		idname[i]=ozflashread(page,offset+i);
	if(findownedbasicfile(idname))
	{
		ozcls();
ozputs0(0,"This BASIC program has data saved in flash.");
ozputs0(10,"To delete BOTH program and data, delete it");
ozputs0(20,"manually in MY PROGRAMS menu.");
ozputs0(30,"Press SPACE to exit.");
ozputs0(50,"(Hit upper MENU key to override and continue deleting,");
ozputs0(60,"leaving orphaned data files.)");
		if(ozgetch()!=KEY_UPPER_MENU) exit(0);
	}
}

main()
{
	static unsigned k;
	static char category;
	static char *f;
	static int slot;
	static byte x,l;
	extern char Line20;
	extern unsigned blk_size;
	static unsigned part2_blk_size;
	static unsigned part2load;
	register byte *s;
	modelM=ozdetectmodel()&MODELMASK_M;
	ozfont(FONT_OZ_NORMAL);
    ozputs(62,1,"USE AT YOUR OWN RISK!");
	ozputs0(11,"by Alexander Pruss and Phil Karau");
	if(modelM)
		ozputs0(21,"(R)un, (D)elete one, or delete (A)ll?");
	else
		ozputs0(21,"(S)ave, (L)oad, (R)un, (D)elete one, or delete (A)ll?");
	ozputs(x,40,"(Any other key to exit.)");
	switch(mygetch())
	{
		case 'r':
			f=selectname();
			if(f==NULL) return;
			ozcls();
			ozputs(ozputs0(0,"Loading: "),0,f);
			if(open1(f,O_RDONLY)<0)
			{
				ozputs0(60,cannotopen);
				ozgetch();
				return;
			}
            part2_blk_size=18+(end_Part2_routine-Part2_routine);
			wrapup_address=WRAPUP_CODE_END-20;
			filetomem();
			wrapup_address=WRAPUP_CODE_END-part2_blk_size;
			ozflashread256(0x409,WRAPUP_CODE_END-256-20-0x6000);
					/* save the last part of page 409 */
			part2load=wrapup_address+0x4000;
			tohex((char*)(wrapup+WRAPUP_PART2_ADDRESS),
				part2load);
			memcpy(buffer,wrapup,18);
			blk_size=18;
			ozmemwrite256(0x409, WRAPUP_CODE_END-18-0x6000);
			Part2_central_addr=part2load+(Part2_central-Part2_routine);
			Part2_indir_addr=part2load+(Part2_indir-Part2_routine);
			memcpy(buffer,Part2_routine,end_Part2_routine-Part2_routine);
			blk_size=part2_blk_size-18;
			ozmemwrite256(0x409, wrapup_address-0x6000);
			/* blk_size=256; */

		/* Install assembly routine "Part2" to end of page 409 */

		 /* Set $E307-8 to the program length */

			* (unsigned int *) 0xE307 = codelength;

		/* Put program name and horz line at top */

			ozcls();
			ozputs0(1,name);
			theline();

		/* Patch BASIC Line 20 to point to the BASIC "Wrap-up", offset= 0x7FDE */

			*(&Line20 + 6 ) = HIBYTE_CONST(WRAPUP_CODE_END-18);
			*(&Line20 + 7 ) = LOBYTE_CONST(WRAPUP_CODE_END-18);
			return;

		case 'd':
		   f=selectname();
		   if(f==NULL) return;
		   ozcls();
		   ozputs(ozputs0(0,"Deleting: "),0,f);
		   unlink(f);
		   return;
		case 'l':
		   if(modelM) return;
		   f=selectname();
		   if(f==NULL) return;
		   ozcls();
		   ozputs(ozputs0(0,"Loading: "),0,f);
		   if(open1(f,O_RDONLY)<0)
		   {
			 ozputs0(60,cannotopen);
			 ozgetch();
			 return;
		   }
		   ozputs0(70,"Preparing slot...");
		   while((slot=clearslot())<0)
		   {
				ozputs0(60,"No slots available!");
				ozputs0(70,"Clear a slot? [y/N]");
				if(ozgetch()!='y') return;
				if((slot=getslot())<0) return;
				confirm_no_basic(slot);
				if(slot+1==ozgetautorun()) ozsetautorun(0);
				ozflashwrite(slot*4+0x60,0,0xF);
		   }
		   filetoslot(slot);
		   return;
		case 's':
		   if(modelM || (slot=getslot())<0) return;
		   ozcls();
           ozputs0(0,"Saving program");
		   getname(slot);
		   strcpy(filename,name);
           ozputs(68/*sizer*/,0,(char*)(s=(byte*)filename));
		   while(*s)
		   {
			  if(*s=='/' || *s=='\\' || *s < 32 || *s >= 127) *s=':';
			  s++;
		   }
           ozputs0(30,"Category? (a-z/space) [none]");
		   k=ozgetch0();
		   if(k>='a' && k<='z')
             ozputch(128,30,category=k);
		   else
		   {
			 category=0;
             ozputs(128,30,"none");
		   }
           ozputs0(40,"Enter filename [");
           x=ozputs(65/*sizer*/,40,filename);
           ozputs(x,40,"]:");
		   if(category)
		   {
			 s=(byte*)filename+2;
			 l=MAX_FILENAMELEN-2;
		   }
		   else
		   {
			 s=(byte*)filename;
			 l=MAX_FILENAMELEN;
		   }
           if(!ozgets(0,50,(char*)s,l))
			 return;
		   if(category)
		   {
			 filename[0]=category;
			 filename[1]='/';
		   }
		   ozputs0(70,saving_msg);
		   if(open1(filename,O_WRONLY)<0)
		   {
			 ozputs0(60,cannotopen);
			 ozgetch();
			 return;
		   }
		   slottofile(slot);
		   return;
		case 'a':
			ozputs0(50,"Really delete all? [N]");
			if(ozgetch()!='y') return;
			ozunlinkallowned();
			return;
	 }
}
